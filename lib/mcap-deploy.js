/*
 * mcap-deploy
 * https://github.com/mwaylabs/mcap-deploy
 *
 * Copyright (c) 2014 mwaylabs
 * Licensed under the MIT license.
 */

'use strict';

var assert = require('assert');
var os = require('os');
var path = require('path');
var formdata = require('node-formdata');
var ignore = require('fstream-ignore');
var request = require('request');
var archiver = require('archiver');
var findup = require('findup');

var ENDPPOINT = '/studio/upload';
var fs = require('fs');
var os = require('os');
var q = require('q');
var organization = 'mway';

var IGNORE_FILES = [".mcapignore", ".gitignore"];
var VError = require('verror');

var getEndpoint = function (baseUrl, endpoint) {
    var ret = '';
    if (baseUrl.lastIndexOf('/') !== baseUrl.length - 1) {
        ret += '/';
    }
    return baseUrl + ret + endpoint;
};

/**
 * Get the current authentication to get the group of the user.
 */
var currentAuthentication = function (options, customRequest) {
    var deferred = q.defer();
    var endpoint = 'gofer/system/security/currentAuthorization';
    var req = customRequest || request;
    var serviceUrl = getEndpoint(options.baseurl, endpoint);
    req.get(serviceUrl, {
        'auth': {
            'user': options.username,
            'pass': options.password
        },
        headers: {
            "Accept": "application/json",
            "Content-Type": "application/json"
        },
        method: 'GET'
    }, function (err, httpResponse, body) {
        if (err) {
            deferred.reject(new VError(err, 'Connection to %s failed', serviceUrl));
            return;
        }
        var data = null;
        try {
            data = JSON.parse(body);
        } catch (err) {
            deferred.reject(new VError(err, 'Server response from %s is corrupt', serviceUrl));
            return err;
        }
        if (data && data.organization && data.organization.uniqueName) {
            organization = data.organization.uniqueName;
            deferred.resolve(data);
        } else {
            deferred.reject(new Error('Authentication failed'));
        }
    });

    return deferred.promise;
};

/**
 * Get the organisation and test if it has defaultRoles. If not raise an error. If an application is generated by a user in a group that has no defaultRoles the application
 * doesn't work as expected.
 */
var getOrganization = function (orga, options, customRequest) {
    assert(orga, 'Missing first parameter orga');
    assert(orga.uuid, 'Missing uuid for organization');

    var deferred = q.defer();
    var endpoint = 'gofer/security/rest/organizations/' + orga.uuid;
    var req = customRequest || request;
    var serviceUrl = getEndpoint(options.baseurl, endpoint);
    req.get(serviceUrl, {
        'auth': {
            'user': options.username,
            'pass': options.password
        },
        headers: {
            "Accept": "application/json",
            "Content-Type": "application/json"
        },
        method: 'GET'
    }, function (err, httpResponse, body) {
        if (err) {
            deferred.reject(new VError(err, 'Connection to %s failed', serviceUrl));
            return;
        }
        var data = null;
        try {
            data = JSON.parse(body);
        } catch (err) {
            deferred.reject(new VError(err, 'Server response from %s is corrupt', serviceUrl));
            return err;
        }

        if (data && Array.isArray(data.defaultRoles) && data.defaultRoles.length > 0) {
            deferred.resolve(data);
        } else {
            deferred.reject('Organization has no defaultRoles. This will cause problems creating applications. Operation not permitted.');
        }

    });

    return deferred.promise;
};

/**
 *
 * @param {Object} options
 * @config {String}   baseurl  mandatory
 * @config {String}   file
 * @config {Object}   fields {
 * @config {Function} progress
 * @config {String}   username
 * @config {String}   password
 * @config {String}   endpoint
 * @returns {promise|*|Q.promise|*|exports}
 */
var upload = function (options, request) {
    // the options for the request
    var endpoint = options.endpoint || ENDPPOINT;
    // add an beginning slash to the endpoint if there is none
    if (endpoint[0] !== '/') {
        endpoint = '/' + endpoint;
    }
    var importOptions = {
        url: getEndpoint(options.baseurl, organization + endpoint),
        headers: {
            "Accept": "application/json"
        },
        method: 'POST',
        file: options.file,
        fields: options.fields,
        progress: options.progress
    };
    if (options.username && options.password) {
        importOptions.auth = {
            "user": options.username,
            "pass": options.password
        };
    }

    return formdata(importOptions, request);
};

var createZip = function (rootPath, dest) {
    var deferred = q.defer();

    var archive = archiver('zip');
    var zipFilePath = dest || path.resolve(os.tmpdir() + '/mcap_app_' + Date.now() + '.zip');
    var output = fs.createWriteStream(zipFilePath);

    ignore({ path: rootPath, ignoreFiles: IGNORE_FILES})
    .on('child', function (c) {
        var name = c.path.substr(c.root.path.length + 1);
        if (c.type === 'File') {
            archive.append(c, { name: name});
        } else if (c.type === 'Directory') {
            archive.append(null, { name: name + '/'});
        }

    }).on('end', function() {
        archive.finalize();
    });

    output.on('finish', function() {
      deferred.resolve(zipFilePath);
    });

    archive.pipe(output);

    return deferred.promise;
};

var deleteZip = function (zipPath) {
    return fs.unlinkSync(zipPath);
};

var getManifestFile = function(rootPath) {
  var deferred = q.defer();

  findup(rootPath, 'mcap.json', function(err, filePath) {
    if (err) {
      return deferred.reject(err);
    }
    deferred.resolve(path.join(filePath, 'mcap.json'));
  });

  return deferred.promise;
};

var getProjectData = function(filePath) {
  var deferred = q.defer();

  fs.readFile(filePath, function(err, content) {
    if (err) {
      return deferred.reject(err);
    }
    var pkg = JSON.parse(content);
    deferred.resolve({
      name: pkg.name,
      uuid: pkg.uuid
    });
  });

  return deferred.promise;
};

var deploy = function (options, request) {
    assert(options, 'Missing argument: options');
    assert(options.baseurl, 'Missing argument: options.baseurl');
    assert(options.rootPath, 'Missing argument: options.rootPath');

    var rootPath = options.rootPath;
    delete options.rootPath;

    return getManifestFile(rootPath)
      .then(getProjectData)
      .then(function(fields) {
        options.fields = fields;
        return options;
      })
      .then(currentAuthentication)
      .then(function (data) {
        return getOrganization(data.organization, options, request)
        .then(function () {
            return createZip(rootPath, options.zipName).then(function (zipPath) {
                options.file = zipPath;
                return upload(options, request)
                .then(function (response) {
                    deleteZip(zipPath);
                    return {
                        zipPath: zipPath,
                        options: options,
                        response: JSON.parse(response),
                        endpoint: getEndpoint(options.baseurl, organization)
                    };
                }, function (err) {
                    deleteZip(zipPath);
                    console.log(''); // Print new line before error reporting.
                    throw new VError('Upload failed: %s', err.body || err);
                });
            });
        });
    });
};

// API
exports.deploy = deploy;

// API for Tests
exports.getEndpoint = getEndpoint;
exports.ENDPPOINT = ENDPPOINT;
exports.upload = upload;
exports.createZip = createZip;
exports.deleteZip = deleteZip;
